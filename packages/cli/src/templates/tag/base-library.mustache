{{#isTypeScript}}
import {
    type CallableTranslations,
    type LangTagTranslations,
    type LangTagTranslationsConfig,
    type PartialFlexibleTranslations,
    createCallableTranslations,
    normalizeTranslations,
    lookupTranslation
} from 'lang-tag';
{{/isTypeScript}}
{{^isTypeScript}}
import { createCallableTranslations, normalizeTranslations, lookupTranslation } from 'lang-tag';
{{/isTypeScript}}
{{#isReact}}
import React, {
    createContext,
    useContext,
    useMemo,
    type ReactNode
} from 'react';
{{/isReact}}

{{#isTypeScript}}
interface TagConfig extends LangTagTranslationsConfig {
    keep?: 'namespace' | 'path' | 'both'
}

/**
* Ensures the Tag type compiles into a named alias rather than an expanded structural type,
* preventing bloated .d.ts output during tag generation and keeping exported definitions clean.
*/
// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace {{tagName}} {
    export type Tag<T extends LangTagTranslations> = {
        useTranslations: () => CallableTranslations<T>;
        initTranslations: (translations?: PartialFlexibleTranslations<T>) => CallableTranslations<T>;
        Provider(props: { translations?: PartialFlexibleTranslations<T>; children: ReactNode }): ReactNode;
        InputType: PartialFlexibleTranslations<T>;
        Type: CallableTranslations<T>;
    };
}

{{/isTypeScript}}
export function {{tagName}}{{#isTypeScript}}<T extends LangTagTranslations>{{/isTypeScript}}(
    baseTranslations: T,
    config?: TagConfig,
){{#isTypeScript}}: {{tagName}}.Tag<T>{{/isTypeScript}} {
    const createTranslationHelper = (normalized{{#isTypeScript}}: CallableTranslations<T> | null{{/isTypeScript}}) =>
        createCallableTranslations(baseTranslations, config, {
            transform: ({unprefixedPath, value, params}) => {
                const fn = normalized && lookupTranslation(normalized, unprefixedPath);
                return processPlaceholders(fn ? fn(params) : value, params);
            }
        });

    {{#isReact}}
    const Context = createContext{{#isTypeScript}}<CallableTranslations<T> | null>{{/isTypeScript}}(null);
    {{/isReact}}

    return {
        {{#isReact}}
        useTranslations: () => {
            const contextTranslations = useContext(Context);
            return useMemo(() => createTranslationHelper(contextTranslations), [contextTranslations]);
        },
        initTranslations: (translations{{#isTypeScript}}?: PartialFlexibleTranslations<T>{{/isTypeScript}}) => {
            const normalized = useMemo(
                () => translations ? normalizeTranslations(translations) : null,
                [translations]
            );

            return useMemo(() => createTranslationHelper(normalized), [normalized]);
        },
        Provider({translations, children}{{#isTypeScript}}: { translations?: PartialFlexibleTranslations<T>; children: ReactNode }{{/isTypeScript}}){{#isTypeScript}}: ReactNode{{/isTypeScript}} {
            const normalized = useMemo(
                () => translations ? normalizeTranslations(translations) : null,
                [translations]
            );

            return <Context.Provider value={normalized}>{children}</Context.Provider>;
        },
        {{/isReact}}
        {{^isReact}}
        initTranslations: (translations{{#isTypeScript}}?: PartialFlexibleTranslations<T>{{/isTypeScript}}) => {
            const normalized = translations ? normalizeTranslations(translations) : null;
            return createTranslationHelper(normalized);
        };,
        {{/isReact}}
        {{#isTypeScript}}
        InputType: {} as PartialFlexibleTranslations<T>,
        Type: {} as CallableTranslations<T>,
        {{/isTypeScript}}
    };
}
